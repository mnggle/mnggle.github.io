<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webRTC多人视频解决方案]]></title>
    <url>%2F2017%2F12%2F15%2FwebRTC%E5%A4%9A%E4%BA%BA%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[你的浏览器很厉害本文的重点是“多人视频解决方案”，所以这里不对webRTC做过多的解释，官网有详细的介绍以及教程。简单的说webRTC（Web Real-Time Communication）它提供了一系列的API，只要通过浏览器就能实现p2p的视频通话，聊天，文件传输等。 在研究利用webRTC实现多人视频的时候，网上没有比较完整的方案或者demo。而且和webRTC相关的很多文档都是英文文档，MDN上很多内容也都是未翻译状态，看起来相对比较吃力，但是既然研究了，我也不想轻易放弃。最终功夫不负有心人，最后琢磨出一个相对可行的方案。有兴趣的同学可以看我自己做的demo的gihub地址https://github.com/mnggle/webrtc-multi，主要内容在branch分支上还没有合并。项目还不完整，代码也有点乱，只是提供一个参考，不过我会一直维护这项目。下面简单介绍一下原理吧。 本次我使用的信令服务器是node+socket.io，由于只是本地调试，所以没有搭建stun/turn服务器。 1、每一个连接都有一个RTCPeerConnection对象。RTCPeerConnection接口代表一个由本地计算机到远端的WebRTC连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。说白了就是端与端之间连接的通道。如果是一对一的视频通讯，那么这个就比较容易实现，官方也有比较好的demo。但是多人的时候就会复杂许多，我的方法是将每一次的端对端连接都建立一个RTCPeerConnection，然后将这个RTCPeerConnection放入一个对象obj中。该对象的key为socket.io提供的，每个终端独有的socket id。value就是RTCPeerConnection。这样就可以通过obj[socket.id]区分当前连接的终端为哪个。 后加入者createOffer在建立连接前涉及到creatOffer和createAnwser问题。关于这两者的用途，官方文档有解释。拿一对一视频来说，A如果想要和B实现视频通话，那么A需要发送一个createOffer给B，B接收到以后需要发送一个createAnwser回复给A，实现的逻辑比较清晰。但是，如果将人数增加到3个人,甚至更多，两两之间都要完成一次createOffer和createAnwser，并且连接的两端各自只能发送createOffer或发送createAnwser。这样一来问题就会变得相对复杂。我的方法是规定，后加入方发送createOffer。即：如果房间内有一个A，B两人，如果C想加入，那么C需要发送createOffer给房间内的其他成员，即这里的A和B，然后A和B接收到C的createOffer后会各自回复对应的createAnwser，以此类推。不过这方法涉及到并发的问题，需要后期解决。不过webRTC多人视频理论上没有连接个数的限制，但是建议保持在4-8个人为好。 以上就是利用webRTC实现多人视频聊天的方案。只是一个粗略的介绍。很多地方可能考虑的不周，希望多多指正，我也能从你们的指正中慢慢完善这个项目。今后我会继续分享webRTC相关的研究成果，这篇文章可以算是一个开始吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员&English]]></title>
    <url>%2F2017%2F10%2F25%2F%E7%A8%8B%E5%BA%8F%E5%91%98-English%2F</url>
    <content type="text"><![CDATA[是时候上演一场我们的猩球崛起了作为一个程序员，或者说作为一只在中国的程序猿，如果能掌握英语，感觉就是基因突变，分分钟上演一场 猩球崛起。什么Google搜索、Stack Overflow、MDN、原文技术文档、原文书，什么和国外开发者交流分享，这都能一刀一个，走上程序员生涯的人生巅峰指日可待。可惜并我没有达到这个境界，以上内容也只是纯属意淫。 不过，作为一个程序员，好像在英语的“听说读写”中只要掌握“读”就行了。在浏览Stack Overflow等一些技术网站的时候配上一本网页字典，不少的文章应该都能get到作者的点，毕竟不是文学，还得咬文嚼字。可如果只能停留在这一步，那么英语就纯粹变成了编程的附属品，有了更好，没有不伤要害。 我总觉得有那么点可惜，我也不仅仅想让英语变成编程的附属品，参加工作以后我也一直在寻找适合我的英语学习法(为什么是参加工作以后呢，上了班的人也应该都明白) 首先，想想我们学英语的时候是怎么学的。反正我以前在学校里，英语课上，老师和学生唯一用英语有效的沟通只有上课前的’good morining xxx.good morining students.sit down please’.然后就开始给我们讲解过去时，一般时，进行时，将来时，过去进行时，过去完成时，现在完成时这些看似条理清楚，但已经被我们一帮学生玩坏的语法，像一万根耳机线缠绕在一起，想解却不知从何开始，不解开始不了。可怜我学了十几年的英语，最后学成了哑巴。每次想开口说的时候，发现脑子一片空白，感觉是被单词，时态，从句这些剪不断理还断的东西封了口。最终用了吃奶的劲挤出几句自我介绍。就像有人让你被一句古诗的时候，你想了想脱口而出：“床前明月光，疑似地上霜….”，不行，我的英语学习生涯不能结束在此。。。那么，接下来，分享几张图片： 这是一张截图，显示的界面是一个叫HINative的APP内的问题界面，这个软APP主要用途就是提问， 问一些你感兴趣国家的问题，可以关于语言，文化，风俗，时事等等，然后会有相应国家的用户来回答你的问题，当然你也可以去回答来自别的国家提问者的问题。言归正传，截图显示得很明显，提问者是一个来自以俄语为母语国家的用户，他提了一个语言类的问题。看到这篇短文，我顿时想起了英语考试时的作文题，我和他写的语言虽然不同，但是效果是相同的。我所说的效果，是指这两方面：第一，虽然我没学过俄语，但我感觉他在写这篇中文作文的时候肯定用上了他俄语的思维方式，导致不少地方出错。第二，虽然他写的地方有很多错误之处，但是我还是明白他想表达的意思。再分享几张图片：上面第一张图是我用英文写的一个小动态。下面一张图是来自摩洛哥用户给我的评论，他帮我修改了几处语法错误。对比我写的和他给我修改的，再次证明了我上面所说的两个效果。 继续对比在学校里死板得学英语，使用这种方式来学英语，感觉really awesome！这种方式完全是在用英语，而不是简单地学。 作为一个程序员，我觉得应该最不怕学的，最不怕用的就是语言了吧，什么 C++,什么java，javascript。等等这些不都是语言吗！只是和英语汉语不同之处在于，这些是和计算机打交道用的。可学习方法应该是相似的吧。试想想在学习编程语言的时候，我们是怎么学的。比如我学习javascript的过程来，我会先学习W3C上面的教程，一个知识点配上若干个demo,然后慢慢一步步地去体会javascript的语法，最后在工作中去运用它。在没学多久之后，我尝试过去学习javascript原理的一些内容，比如原型链，继承，执上下文这些知识点，那时候我看的云里雾里，似懂非懂。但在经过一段时间的学习工作以后，在慢慢去回顾这些东西，发现豁然开朗。 总结一下，5个字：先用了再说。我坚信这种方式的有效性，我也期待我的进步。 写这篇随笔，并不想说在学校学英语的方式有多么差，我只是想分享一下我自己觉得有用，并且快乐的学习英语的方式。而且作为一个非英语母语国家，如果缺少了语法，和单词，想光靠聊个天，发个说说来提升自己的英语素养，那简直就是痴人说梦。不过如果你有的是钱，有的是时间那就可以忽略上一句，或者这篇文章。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立即执行函数表达式]]></title>
    <url>%2F2017%2F10%2F13%2F%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[雷厉风行的无名氏立即执行函数表达式(Immediately-Invoked Function Expression)，顾名思义，就是通过这种语法， 可以让函数在定义的时候立即被执行。 立即执行函数表达式(Immediately-Invoked Function Expression)，顾名思义，就是通过这种语法， 可以让函数在定义的时候立即被执行。 大概知道了立即执行函数的概念，先来看一下以下三种写法，哪个才是真正的立即执行函数表达式呢？123456//1function()&#123; /* code */ &#125;();//2function foo()&#123; /* code */ &#125;();//3(function()&#123; /* code */ &#125;()); 以上三种写法中，只有第三种是货真价实的立即执行函数表达式，其他的都会报错，其实也很好理解是为什么，解析器在解析javascript代码的时候，当遇到function关键字，会默认把它当做一个函数声明，而不是函数表达式。第一种报错的原因很明显，少一个函数名。第二种报错的原因相对来说比较隐蔽，这段代码准确来说是这样的：12function foo()&#123; /* code */ &#125;;(); 相当于先声明了一个foo函数，之后跟了一个()，这个东西叫分组运算符。函数foo和这个分组运算符其实是没有关系的，只是看起来像在调用函数。报错的原因是分组运算符不能为空，不信你可以在这个分组操作符内放入一些内容，看看是否还报错。 解释了为什么错，现在解释一下为什么第三种写法是对的：因为在javascript里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()，然后碰到function关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。 以下是立即执行函数的多种写法。1234567891011121314151617181920// 最常用的两种写法(function()&#123; /* code */ &#125;()); // 老道推荐写法(function()&#123; /* code */ &#125;)(); // 当然这种也可以 // 括号和JS的一些操作符（如 = &amp;&amp; || ,等）可以在函数表达式和函数声明上消除歧义// 如下代码中，解析器已经知道一个是表达式了，于是也会把另一个默认为表达式// 但是两者交换则会报错var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); // 如果你不怕代码晦涩难读，也可以选择一元运算符!function()&#123; /* code */ &#125;();~function()&#123; /* code */ &#125;();-function()&#123; /* code */ &#125;();+function()&#123; /* code */ &#125;(); // 你也可以这样new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 带参数 说白了，你让解析器认为你写的是函数表达式就行了。但是个人觉得使用()的方式会更好些，其他几种虽然也是立即执行函数表达式，但看起来真有点丑。借用一句歌词—“简单点，说话的方式简单点” 弄明白对错以后，重点来了： 在javascript中，每一个函数在被调用的时候都会创建一个执行上下文，在该函数内部定义的变量和函数只能在该函数内部被使用，而正是因为这个上下文，使得我们在调用函数的时候能创建一些私有变量。 首先，看例子。像普通的函数传参一样，立即执行函数也能传参数。如果在函数内部再定义一个函数，而里面的那个函数能引用外部的变量和参数（闭包），利用这一点，我们能使用立即执行函数锁住变量保存状态。12345678910111213141516171819202122232425262728293031// 并不会像你想象那样的执行，因为i的值没有被锁住// 当我们点击链接的时候，其实for循环已经执行完了// 于是在点击的时候i的值其实已经是elems.length了var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + i ); &#125;, 'false' ); &#125; // 这次我们得到了想要的结果// 因为在立即执行函数内部，i的值传给了lockedIndex，并且被锁在内存中// 尽管for循环结束后i的值已经改变，但是立即执行函数内部lockedIndex的值并不会改变var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; (function( lockedInIndex )&#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;, 'false' ); &#125;)( i ); &#125; 我是这么理解的：第二种方法，在for循环过程中，相当于创建了n个闭包也就是n个函数，而因为每个函数在被调用的时候都会创建一个执行上下文，而每一个执行上文中都会有不同参数lockedIndex，所以在点击的时候会出现不同的值。关于执行上下文怎么理解接下来的博文中会有写到。 说一个题外的知识点：如果使用上es6语法中的let命令来解决上面的问题，那么会简单很多。12345678910var elems = document.getElementsByTagName( 'a' ); for ( let i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + i ); &#125;, 'false' ); &#125; 虽然是题外的知识点，但是其实let命令，和立即执行函数，在解决这个问题上面，有异曲同工之处。关于es6的语法具体可以参考阮一峰老师的ECMAScript 6 入门 http://es6.ruanyifeng.com/ 主要参考：http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iifehttp://web.jobbole.com/82520/http://blog.csdn.net/qq838419230/article/details/8030078]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 笔记 原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿甘正传-JUST RUNNING]]></title>
    <url>%2F2017%2F10%2F02%2F%E9%98%BF%E7%94%98%E6%AD%A3%E4%BC%A0-%E5%88%AB%E6%83%B3%E5%A4%AA%E5%A4%9A%EF%BC%8Cjust-running%2F</url>
    <content type="text"><![CDATA[一部好电影不能随随便便就看了 今天看了《阿甘正传》，这部电影其实早就想看了也早已下载到我的电脑上，但是总觉得一部好电影不能随随便便就看了，然后就一直存在我的磁盘里。。。 &ensp;&ensp;不知是否是错觉，这部电影剧情好像很平淡，似乎没有开始，高潮，结束。更像是一个人的口述，也的确是如此，剧中主人公阿甘也同时扮演者这样一位有着各种经历的口述者，他只负责讲故事，至于从中得到什么，是你的事情。 这让我想起了余华的《活着》 这本书的叙事方式是以故事主人公徐富贵的自述方式进行。叙述朴素，不紧不慢，在读的过程中一度怀疑有流水账的倾向，平铺直叙。但看着看着我渐渐明白了作者的用意，就像作者所说的那样，“生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法。 其实《阿甘》也好《活着》也好，这两者的故事内容并不平淡，只是用平淡的方式叙述，反差下更引人深思。 阿甘生来白痴，却上了大学，在橄榄球球场上以一敌百，在越南战争中不怕空袭救战友，一玩乒乓球就精通，甚至因为自己心情不好出去跑步也掀起一场舆论。他的所做过的事，几乎没有一件是他想做的，或者是曾计划过去做的。正如阿甘所说的：人生就像一盒各式各样的巧克力，你永远不知道下一块会是哪种。 不过，他并不只是简单地接受生活带给他的各种巧克力，他听从妈妈的教训，珍妮的劝告，听从内心，做好每件事。当生活要拿走在他手里蓬勃发展的事业的时候。他没有过多的抱怨，而是放下这些羁绊继续向前。就像剧始剧末的那根羽毛一样，电影刚开始，羽毛被阿甘夹入故事书，电影结束，阿甘打开书本，那根羽毛，轻轻的，风一吹转几下就走了。人不能一直被自己的抱怨耽误，被自己的过去拖累。 看了一篇关于《阿甘正传》的影评，上面提到“无为”。我对这种高深的思想没有研究，引用一下来自百度对“无为”的解释。 无为指经过有为的思考，以潮流的判断做出顺势而为的行为，即顺应自然的变化规律，使事物保持其天然的本性而不人为做作，从而达到“无为而无不为”的境界。 “从而达到“无为而无不为”的境界”，听起来很耐人寻味，那个味到底是什么，得慢慢体会，即便是寻到了，想做到，难上加难。单从我自己来说，我应该属于那种容易被自己过去拖累，容易抱怨的人，只是程度没有那么深，可江山易改本性难移，很多观念，很多习惯，不是说改就能改的，即使是死板的程序，在进行更新迭代的时候也会出各种各样的BUG呢。 所以，想那么多有什么用呢，像阿甘一样，just running!]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript原型链笔记]]></title>
    <url>%2F2017%2F09%2F22%2Fjavascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[只停留在会用的层面，这比纯理论来的更可怕 最近在阅读underscore.js的源码，过程中，发现有必要好好学习一下javascript原型链的知识。参考了不少的博客，也翻阅了《javascript高级程序设计》。由于原型链这块确实有点绕，怕自己过段时间忘了，所以趁热打铁做一下总结。 本文从“对象”和“函数”切入： 1. 一切（引用类型）都是对象，对象是属性的集合这句话不用想太多，直接上例子。1234567891011console.log(typeof x);// undefinedconsole.log(typeof 10); // numberconsole.log(typeof 'abc'); // stringconsole.log(typeof true); // booleanconsole.log(typeof function () &#123;&#125;); //functionconsole.log(typeof [1, 'a', true]); //objectconsole.log(typeof &#123; a: 10, b: 20 &#125;); //objectconsole.log(typeof null); //objectconsole.log(typeof new Number(10)); //object' 可以看到数组，对象，null，以及用new Number()构造出来的内容使用 typeof操作符返回的值都是Object。放下基本类型不管，这里有一个特殊的返回值function ，那么问题来了，function 到底是啥呢，是不是对象呢。 2.函数是一种对象12var fn = function () &#123; &#125;;console.log(fn instanceof Object); // true 从上例可以看到，使用instanceof运算符 得到函数fn和Object之间存在关系。借用MDN上对instanceof运算符的解释： instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 可以进一步确定，函数fn是对象的一种形式。如果觉得这句话莫名其妙。那么记住下面这句话： 函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑。 举个例子加强印象：123456789101112var fn = function () &#123; alert('我是一个函数') &#125;;fn.a = 10;fn.b = [1,2,3];fn.c = &#123; name:'对象'， value:'函数下的对象'&#125;fn.d = function()&#123; alert('我是函数下的函数')&#125; 上例中，函数fn就被当做对象被赋值了一些属性。fn是一个属性的集合。 3.对象都是通过函数创建的1var obj = new Object(); 这种创建对象的方式肯定见过。包括数组也是如此。1var arr = new Array(); 其实可以通过 typeof操作符来说明问题。12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 可以看出Object和Array都是函数，而上面的对象obj和数组arr分别被这两个函数创建。 再来一个例子。123456function Person()&#123; this.name = 'muggle', this.job = 'FE' this.age = 18&#125;var person1 = new Fn();//&#123;name: "muggle", job: "FE", age: 18&#125; 4.慢慢体会总结一下2、3两点：函数是对象的一种，对象都是通过函数创建的。。。呃。。。什么鬼？ 直接上图： 结合一下几句话： 每个对象都有一个__proto__属性（隐式原型），指向创建该对象的函数的prototype 每个函数都有一个属性叫做prototype。 Object.prototype确实一个特例——它的__proto__指向的是null Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的__proto__指向了自身的Prototype 调用构造函数创建实例会经历一下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 接来下就可以顺着这张图的每一条线慢慢体会了。 原型链的知识还是挺多的，即使理解了一些原理，但是想要完全掌握它还是需要在接下来的工作学习中慢慢体会。很多原理性的东西要结合了实际才会有味道。毕竟我不是理论科学家，不想纯研究理论。我也不想当无脑码农，只停留在会用的层面，这比纯理论来的更可怕。 主要参考： http://www.cnblogs.com/wangfupeng1988/p/3977924.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 笔记 原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2边学边用之“.sync ”修饰符]]></title>
    <url>%2F2017%2F07%2F26%2F%E8%BE%B9%E5%AD%A6%E8%BE%B9%E7%94%A8vue2%E4%B9%8B-sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[相比angularjs，vue的学习曲线真的是如丝一般润滑。由于公司需要将原来使用anuglar的项目改为使用vue，最近一直忙于对于vue的学习和使用，相比angularjs，vue的学习曲线真的是如丝一般润滑。故想在边学边用之余总结一些开发过程中遇到的问题和get到的点。这次分享的是 .sync 修饰符。 首先来一张官方文档的截图： 从上图的介绍中我们可以得知， .sync 修饰符是为了能让prop实现双向绑定，在开发过程中，由于组件的复用，很多时候确实需要从子组件中获取数据。而官方文档又规定prop是单项绑定的，即父组件属性发生变化，将传导给子组件，但是不会反过来。如demo所示: 12345678910111213141516171819202122232425&lt;!-- 父组件代码 --&gt;&lt;template&gt; &lt;div class="parent"&gt; &lt;child :testValue="testValue"&gt;&lt;/child&gt; &lt;p&gt;&#123;&#123;testValue&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from './child'export default &#123; data () &#123; return &#123; testValue: '来自父级的值' &#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, created () &#123;&#125;, components: &#123; child &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122&lt;!-- 子组件代码： --&gt;&lt;template&gt; &lt;div class="child"&gt; &lt;input type="text" name="" v-model="testValue"&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; props: &#123; testValue: String &#125;, data () &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, created () &#123;&#125;, components: &#123;&#125;&#125;&lt;/script&gt; 按照上述写法，在input中输入值不仅无法实现双向数据绑定，在控制台也会报错： 这是由于vue不允许你直接改变prop的值，想要改变必须在父组件中加入.sync修饰符，并且当子组件想要更新prop时，需要显式地触发一个事件demo如下： 12345678910111213141516171819202122232425&lt;!-- 父组件代码 --&gt;&lt;template&gt; &lt;div class="parent"&gt; &lt;child :testValue.sync="testValue"&gt;&lt;/child&gt; &lt;p&gt;&#123;&#123;testValue&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from './child'export default &#123; data () &#123; return &#123; testValue: '来自父级的值' &#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, created () &#123;&#125;, components: &#123; child &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526&lt;!-- 子组件代码 --&gt;&lt;template&gt; &lt;div class="child"&gt; &lt;input type="text" name="" :value="testValue" @input="changeTest"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; testValue: String &#125;, data () &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, methods: &#123; changeTest (event) &#123; this.$emit('update:testValue', event.target.value)// 显式触发一个更新事件 &#125; &#125;, created () &#123;&#125;, components: &#123;&#125;&#125;&lt;/script&gt; 如此就将子组件的属性变化传递给了父组件。然而事情还没完。在原来的基础上将传递的值改为一个对象的时候： 1234567&lt;!-- 父组件代码 --&gt;&lt;template&gt; &lt;div class="parent"&gt; &lt;child :testObj="testObj"&gt;&lt;/child&gt; &lt;p&gt;&#123;&#123;testObj.message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 123456&lt;!-- 子组件代码 --&gt;&lt;template&gt; &lt;div class="child"&gt; &lt;input type="text" name="" v-model="testObj.message"&gt; &lt;/div&gt;&lt;/template&gt; 父组件并没有使用.sync修饰符，子组件也没有显式地提交一个事件，但是改变输入框的内容，父组件也发生了变化。说好的单向绑定，单向数据流呢。其实。。。在官方文档中有说明了： 尤大也在vue的 某个issue中说了 人家只是长得像而已，别误会了!基础原理的只是在开发过程中真的很重。。不然不是瞎猫碰上死耗子，就是瞎猫死在耗子手上。 引用类型可以参考这篇文章：http://www.qdfuns.com/notes/17660/7f82003c5ce92d39d19d6be0403f3f3b.html]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多行文字垂直居中的方法]]></title>
    <url>%2F2017%2F06%2F01%2F%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单行文字在容器内垂直居中很简单，多行咋办？单行文字在容器内垂直居中很简单，只要加一个line-height就可以轻松解决。但想要让多行文字垂直居中，使用line-height就很尴尬了。本文介绍如何使用display：table的方法实现文字的多行居中。 HTML代码： 123&lt;div class="box"&gt; &lt;p class="text"&gt;第一行文字&lt;br&gt;第二行文字&lt;br&gt;第三行文字&lt;/p&gt;&lt;/div&gt; CSS代码：1234567891011121314*&#123;margin: 0;padding: 0;color: #fff;&#125;.box&#123; display: table; background-color: #105B63; margin: 100px auto; width: 500px; height: 500px; text-align: center; border:1px #000 solid;&#125;.text&#123; display: table-cell; vertical-align: middle;&#125; 如下图所示实现了文字的垂直居中。 但是在ie7中打开发现并没有生效解决此兼容问题的方法，只能在ie浏览其中使用定位的方法。 HTML代码：12345&lt;div class="box"&gt; &lt;div class="inner-box"&gt; &lt;p class="text"&gt;第一行文字&lt;br&gt;第二行文字&lt;br&gt;第三行文字&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS代码：1234567891011121314151617181920212223*&#123;margin: 0;padding: 0;color: #fff;&#125;.box&#123; position:relative; display: table; background-color: #105B63; margin: 100px auto; width: 500px; height: 500px; text-align: center; border:1px #000 solid;&#125;.inner-box&#123; display: table-cell; vertical-align: middle; *position: absolute; *width: 100%; *top: 50%; *left: 0;&#125;.inner-box p&#123; *position: relative; *top:-50%;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Atom的配置同步到Github]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B0%86Atom%E7%9A%84%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[配置不能同步？每次都是最熟悉的陌生人 Atom这么多的自定义内容，万一哪天电脑一睡不醒，和自己磨合了很久的自定义内容也就一睡不醒了。本文就来介绍一下如何将Atom的配置同步到Github上。 1、安装sync-settings插件 命令行安装: $ apm install sync-settings 设置中心: 搜索sync-settings 在通过命令行安装的时候，windows用户需要配置一下环境变量。将C:\Users\Administrator\AppData\Local\atom\bin放入系统变量的path中。 打开CMD/bash切换目录到atom的插件目录执行 $ cd ~/.atom/packages 使用 $ apm install sync-settings 安静地等它安装完成吧，最好开个代理再安装，不然可能会很慢。 2、配置插件安装完成后，点击插件进入插件配置页面 如图所示分别输入Person Access Token和Gist Id(下面勾选的内容是你要同步的内容) 获取Person Access Token： 登录github，点击头像&gt;Settings，选择侧边栏中的Person Access Token。 配置好后点击创建按钮（由于我已经配置过，所以这里的按钮是update。下面的选项可以按需选择，这次记得要选中gist） 生成的Token序列最好记一下，下次在另一台电脑上获取备份配置的时候需要用到。不记也没关系， 可以重新生成。 创建后会有生成token 序列，将他复制到sync-settings插件设置的Person Access Token输入框中。 获取Gist Id： 在github中创建一个gist，如图所示，点击生成之后将生成的gistId复制到sync-settings插件设置的gist id输入框中。 在另一台电脑上想要获取这个值，只需找到这个gist配置文件，点开后，浏览器地址栏后面的一串值就是gist id。 3、备份打开Atom Ctrl + Shift + P 输入sync，就会出现一下几个选项，选择Backup即开始备份。 sync-settings:backup 备份设置 sync-settings:restore 复原备份 sync-settings:view-backup 查看备份 sync-settings:check-backup 查看是否是最新的备份 sync-settings:fork fork配置]]></content>
      <categories>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
